{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-11-14T01:09:05.879254+00:00",
  "repo": "martinthomson/train-protocol",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMaSf_M6Qn1aP",
      "title": "How do we protect from spoofed packets?",
      "url": "https://github.com/martinthomson/train-protocol/issues/1",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We have a risk that some \"man on the side\" will inject spoofed packets for fun and profit. We need to consider that in the security section. We have basically two level of protection:\r\n\r\n1) The attacker needs to see the original traffic in order to learn connection IDs, etc.\r\n2) The receiver can verify that the packet decrypts correctly after resetting the version ID.\r\n\r\nThe combination of the two is probably OK: it proves that the network element was able to receive a packet and change it. But in the case of packets sent after the handshake completes, the keys have been discarded and there is no way to do any verification. The only security is the check of the CIDs. Is that sufficient?",
      "createdAt": "2024-07-24T00:44:35Z",
      "updatedAt": "2024-08-07T20:19:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "I currently have text in the draft that says that you only accept signals that have the modified version when there is a packet in the same datagram that is accepted.  This does not prevent an off-path attacker that is able to observe a valid packet from trying to race a modified packet toward the receiver, but I think that this is the best we can manage.",
          "createdAt": "2024-07-24T14:29:56Z",
          "updatedAt": "2024-07-24T14:29:56Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "(oops, wrong window)",
          "createdAt": "2024-08-07T20:07:19Z",
          "updatedAt": "2024-08-07T20:19:50Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOMaSf_M6Qn4ui",
      "title": "Transport parameter",
      "url": "https://github.com/martinthomson/train-protocol/issues/2",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The mechanism provides a bandwidth limit to the receiving endpoint, by rewriting the version field of long header packets. It does require some cooperation of the endpoints:\r\n\r\n* be willing to receive packets with version set to one of the reserved values,\r\n* be willing to send long header packets after the handshake is complete,\r\n* if the bandwidth parameter describes a \"max send rate\", be willing to relay the value to the peer. (This would not be needed if the bandwidth parameter indicated \"max receive rate\".)\r\n\r\nI think we need to define a transport parameter to negotiate that.",
      "createdAt": "2024-07-24T00:59:12Z",
      "updatedAt": "2024-08-20T06:57:14Z",
      "closedAt": "2024-08-20T06:57:14Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "I don't think that we need a transport parameter for that purpose.  The only thing I might suggest is necessary is the negotiation of a new frame that solicits the sending of a long header packet.  Even that, I'm less sure about.  Endpoints can periodically stuff a small, pointless, long header packet in a datagram that they are sending.\r\n\r\nRelaying the received max send rate to a peer is an application matter.",
          "createdAt": "2024-07-24T14:31:47Z",
          "updatedAt": "2024-07-24T14:31:47Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Endpoints can periodically stuff a small, pointless, long header packet in a datagram that they are sending.\r\n\r\nFWIW it is my understanding that such behavior is already allowed explicitly in [Section 14.4.1 of RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-pmtu-probes-containing-sour).\r\n\r\nAll we are doing here is exercising an existing mechanism. We do not need TP. If we find out endpoints break due to seeing long header packets post-handshake, those endpoints are broken.",
          "createdAt": "2024-07-24T22:49:50Z",
          "updatedAt": "2024-07-24T22:49:50Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "We also need a new frame to echo the bandwidth indicated by the network. But that can be negotiated by version negotiation.",
          "createdAt": "2024-07-25T00:59:02Z",
          "updatedAt": "2024-07-25T00:59:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "I agree with Kazuho on this point.",
          "createdAt": "2024-07-26T00:16:39Z",
          "updatedAt": "2024-07-26T00:16:39Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure who agrees on what at this point. The discussion on PR#8 strongly hints that we in fact need a transport parameter. Hard to have a version-neutral variant without that.",
          "createdAt": "2024-07-28T03:47:38Z",
          "updatedAt": "2024-07-28T03:47:38Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOMaSf_M6QtzGK",
      "title": "Jana's notes",
      "url": "https://github.com/martinthomson/train-protocol/issues/4",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Things to write about:\r\n\r\n    matrix of different signal semantics and responses\r\n    Why is this achievable with ecn but it is different from ecn\r\n    argue that this doesn\u2019t change operator behavior but exposes it\r\n    escape hatch for how end points can stop listening to this signal",
      "createdAt": "2024-07-24T15:46:00Z",
      "updatedAt": "2024-07-24T15:46:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOMaSf_M6Qwyv0",
      "title": "Switch from \"rewriting\" to \"injecting\"",
      "url": "https://github.com/martinthomson/train-protocol/issues/5",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current design suggests middleboxes rewrite QUIC packets.\r\n\r\nThis approach has the following problem:\r\n* If middleboxes rewrite ordinary QUIC packets (e.g., V1) as the current draft suggests, it would have negative performance impact to existing stacks, as the rewrite would lead up to packet loss events.\r\n* We could define a trigger version, but that requires coordination on both endpoints. While that is possible, the concern is that the design might become dependent to the internals of specific version of QUIC (see #3). What we prefer is a design neutral to QUIC versions (or a design that works with UDP-based protocols other than QUIC).\r\n\r\nSo what about the following:\r\n* Instead of rewriting packets, let middleboxes *inject* long header QUIC packets. The QUIC version number field identifies that the packet carries bandwidth information. The bandwidth information itself can be encoded as part of the version number, or it can be the payload of the long header packet.\r\n* The receiver verifies if the injected packet is from a on-path device, by verifying the CID pair of the QUIC packet. This works because QUIC deployments use non-zero length CID in at least one direction.\r\n\r\nTo paraphrase, middleboxes that observe a long header QUIC packet can simply copy the Destination CID and Source CID fields of the QUIC packet, and inject a new QUIC packet using the same CID pair, with a special version number(s) indicating that the information is from the middlebox.\r\n\r\nAs said, the benefit of this approach is that it would work with any version of QUIC, and that there would be no negative impact to the throughput of existing QUIC stacks. Also, the protocol can be used by other UDP-based protocols, provided that they define a way for endpoints to agree on the value of CID fields used for validation.\r\n\r\nWDYT?",
      "createdAt": "2024-07-25T00:43:45Z",
      "updatedAt": "2024-08-21T04:36:37Z",
      "closedAt": "2024-08-21T04:36:19Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Christian and I are talking about doing a completely new QUIC version, which addresses the packet drop risk.\r\n\r\nMy understanding is that replacement is far easier than insertion for a middlebox, to the extent that anything else is likely a non-starter.",
          "createdAt": "2024-07-25T16:33:42Z",
          "updatedAt": "2024-07-25T16:33:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My assumption has been that the middleboxes that send TRAIN packets are going to be the sophisticated ones and that they can inject packets like they do with ICMP packets. But I could very well be incorrect.\r\n\r\nThat said, I think rewriting is fine.\r\n\r\nSeparately, I would point out that the receiver cannot distinguish between a rewritten packet and an injected packet if Initial packets are allowed to carry the bandwidth information, as they are not encrypted using keys known only to the endpoints.",
          "createdAt": "2024-07-25T21:32:55Z",
          "updatedAt": "2024-07-25T21:32:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Rewriting helps if you consider it likely that there could be an attacker that can observe and inject packets on the path.  The conditions for success there aren't great, but it is an attack modality that is easier to block than document :)\r\n\r\nThe point about the Initial packet is well-taken.  Particularly if an off-path attacker is willing to accept a high risk of failure.  Though I would observe that there are limits to what an attacker might achieve in most of these adaptive bit rate scenarios.",
          "createdAt": "2024-07-31T02:44:19Z",
          "updatedAt": "2024-07-31T02:44:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "@kazuho with the new design, are you comfortable closing this issue?  I think that we're in pretty good shape overall.  We'll need to expand on the attack modalities stuff though.",
          "createdAt": "2024-08-21T02:43:39Z",
          "updatedAt": "2024-08-21T02:43:39Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, let's close.",
          "createdAt": "2024-08-21T04:36:36Z",
          "updatedAt": "2024-08-21T04:36:36Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOMaSf_M6Q3kfa",
      "title": "shotgun thumpers",
      "url": "https://github.com/martinthomson/train-protocol/issues/6",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am a bit concerned that the simplistic way for intermediaries to implement the \"tumping\" is to write something like:\r\n~~~\r\n    if(*(uint32_t*)&packet[1] == TRAIN_VERSION) {\r\n        *(uint32_t*)&packet[1] = PACING_RATE_VERSION;\r\n    }\r\n~~~\r\nThis will work well 99.9999% of the time, but if will also catch the 1RTT packets in which the CID bytes happen to match the chosen version, or one of the reserved versions that match rates. There are two dozen such versions, so the probability is about 1/2^28. Not large, but it makes for a silly heisenbug. Pick one of the wrong CIDs and your packets get mangled in traffic.\r\n\r\nOf course, this does not happen if the test is written as:\r\n~~~\r\n    if((packet[0]&0xc0) == 0xc0 && *(uint32_t*)&packet[1] == TRAIN_VERSION) {\r\n        *(uint32_t*)&packet[1] = PACING_RATE_VERSION;\r\n    }\r\n~~~\r\n... but that means we have to fight laziness, because the wrong code is shorter and also \"almost right\".\r\n\r\nSo maybe we should be very explicit about that in the text.",
      "createdAt": "2024-07-25T16:26:32Z",
      "updatedAt": "2024-08-20T06:57:15Z",
      "closedAt": "2024-08-20T06:57:15Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the new design will fix the issue. Messing with the top byte of a V1 packet will cause the checksum to fail.",
          "createdAt": "2024-08-07T16:58:51Z",
          "updatedAt": "2024-08-07T16:58:51Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMaSf_M6Q5qwa",
      "title": "the design should be QUIC-version neutral",
      "url": "https://github.com/martinthomson/train-protocol/issues/8",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current design requires changes to specification and the program being deployed to the middleboxes, each time a new QUIC version is deployed.\r\n\r\nTo paraphrase, we are introducing the incentive for middlebox vendors to block unknown versions of QUIC to which they cannot provide bandwidth information (or give preferential treatment to some versions of QUIC to which they can provide bandwidth).\r\n\r\nI think what we need to design is a bandwidth notification mechanism that is neutral to QUIC versions.\r\n\r\nOne way of achieving that goal would be to use the special version number solely for exchanging the bandwidth information (or for triggering rewrites). To give an example, and endpoints would exchange QUIC v1 packets as-is, but occasionally also send QUIC vXXXX packets which would be rewritten by the middleboxes.",
      "createdAt": "2024-07-25T21:52:24Z",
      "updatedAt": "2024-08-20T06:57:15Z",
      "closedAt": "2024-08-20T06:57:15Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we risk building an ossification vector. We converge on a mechanism in which we negotiate a \"TRAIN\" version, as in:\r\n\r\n* client starts with version=1, send initial packet, transport parameters indicate support for version=TRAIN,\r\n* server agrees to version=TRAIN, defined as \"just like version 1 but with a different encoding of VN in long packets\",\r\n* intermediaries see version=TRAIN, replace with version=TRAIN(10mbps).\r\n\r\nWith that rule, we would need different version numbers for TRAIN(of Version1), TRAIN(of Version2), etc. But the intermediaries will only recognize TRAIN(version1). Thus ossification.\r\n\r\nThe desired solution would have something like:\r\n\r\n* client starts with version=1, transport parameters indicate support vor V2 and V3, and also for the TRAIN mechanism.\r\n* server accepts version 3, says so in transport parameters, and accepts to use the TRAIN mechanism.\r\n* at some point, client and server send long header packets with version=TRAIN. These packets are decoded with the version selected.\r\n\r\nFor the handshake, I think that implies some kind a train handshake before sending VN=TRAIN. Something like:\r\n\r\n* client starts with version=1, transport parameters indicate support or V2 and V3, and also for the TRAIN mechanism.\r\n* server accepts version 3, says so in transport parameters, and accepts to use the TRAIN mechanism. This is carried in initial and handshake packets with version = 3.\r\n* client  decodes all that, then sends handshake packet with version = TRAIN. \r\n* server receives that packet, knows that TRAIN (or variants) shall be decoded as if it were the negotiated version (3 in that example).\r\n* server sees that the client has sent TRAIN packet, can send TRAIN packets itself.",
          "createdAt": "2024-07-25T22:07:44Z",
          "updatedAt": "2024-07-25T22:07:44Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema Thank you for your comments. I think we are almost on the same page.\r\n\r\n> The desired solution would have something like:\r\n\r\nConsidering that the endpoints are never going to use version=TRAIN for exchanging data, I think the version does not need to be covered by Compatible Version Negotiation. The only information each endpoint need to notify to the peer is that it can decode BANDWIDTH frames.\r\n\r\n> For the handshake, I think that implies some kind a train handshake before sending VN=TRAIN. Something like:\r\n\r\nWhile we can define when version=TRAIN packets should be sent, I am not sure if it's worth defining.\r\n\r\nI might argue that they can be sent at any moment, regardless of the peer having support for train. Doing so has no negative effect (modulo the cost of sending a packet that never gets used), while having the benefit of hiding endpoints' capabilities from getting exposed onto the network.\r\n\r\nEndpoints that are capable of handling version=TRAIN packets will buffer the bandwidth information, and sends the BANDWIDTH frame once 1-RTT keys become available (and if the peer has sent the TP).",
          "createdAt": "2024-07-25T22:25:24Z",
          "updatedAt": "2024-07-25T22:25:24Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOMaSf_M6SB3BN",
      "title": "Attack by malicious endpoint",
      "url": "https://github.com/martinthomson/train-protocol/issues/11",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We are worried about attacks by the network, but it is also possible for an endpoint to send the 6bits in the header to an arbitrary value. Maybe this is just a variant of the spoofing attack, but it is simpler to implement. And endpoint that wants to sabotage a local network could set the 6bits to indicate \"tons of bandwidth\" and DOS its own connection...",
      "createdAt": "2024-08-06T05:14:14Z",
      "updatedAt": "2024-08-07T16:57:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Given that the endpoint that can spoil the message is also the endpoint responsible for sending, I'm struggling to see how this would be a problem.",
          "createdAt": "2024-08-06T05:20:51Z",
          "updatedAt": "2024-08-06T05:20:51Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Correct. The malicious endpointcannot really do anything useful this way. OTOH, if the endpoint could report a fake value to the peer, tricking that peer into sending too much data.\r\n\r\nThis looks like a variant of spoofed ACKs.",
          "createdAt": "2024-08-06T06:13:27Z",
          "updatedAt": "2024-08-06T06:13:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Yes, if we provide a feedback signaling mechanism, that will be vulnerable to all sorts of misrepresentation.  Again, we should acknowledge and move on.",
          "createdAt": "2024-08-06T09:23:16Z",
          "updatedAt": "2024-08-06T09:23:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Not too sure above \"move on\". We did include in QUIC a defense against spoofed ACK. We could easily include a defense about spoofed reports. For example, in some TRAIN packets, the server puts a specific value in the 6 bits. If the client reports a value greater than that, the server knows that TRAIN cannot be trusted on that path.",
          "createdAt": "2024-08-06T13:56:35Z",
          "updatedAt": "2024-08-06T13:56:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a reason to talk specifically about attack from endpoints?\r\n\r\nMy understanding is that they are indistinguishable from attacks by middleboxes, as the bandwidth information is not covered by AEAD.\r\n\r\nIt might make sense to point out that the receiver of TRAIN can mount the same attack as middleboxes might, but that would be it, I think.",
          "createdAt": "2024-08-07T00:37:57Z",
          "updatedAt": "2024-08-07T00:37:57Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe close this one, but retain the idea that endpoints could try to find out fakers (middlepoints or endpoint) by sending a probe with some arbitrary value, and verify that the echoed value is lower or equal. Kind of like setting holes in the sequence number to catch optimistic ACK.",
          "createdAt": "2024-08-07T16:57:11Z",
          "updatedAt": "2024-08-07T16:57:11Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOMaSf_M6SI_yD",
      "title": "Source Connection ID value",
      "url": "https://github.com/martinthomson/train-protocol/issues/13",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "What do we set this to?  I've suggested that this be empty, but that might be inconsistent with other packets in the same datagram.\r\n\r\n",
      "createdAt": "2024-08-06T23:13:16Z",
      "updatedAt": "2024-08-21T07:51:24Z",
      "closedAt": "2024-08-21T07:51:24Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "We have two contracts that have different properties.\r\n\r\nOne is the three-party contract between the endpoints and the network device. I think we are in agreement that network devices must take the version number field (which will be vTRAIN) and the first byte into consideration, and may also take DCID into consideration. IMO, the flip side is that there is no necessity to be specific about how the SCID field is used between the endpoints.\r\n\r\nThe second contract is the two-party contract between the endpoints. As the RFCs state, QUIC connections are identified using CIDs.\r\n\r\nThe two contracts are going to be inherently different in the details. The three-party contract will allow CIDs as large as 2040 bits, because that's the Invariant. The two-party contract of QUIC v1 forbids use of CIDs longer than 160 bits.\r\n\r\nI think this is a precedence that we have set. Nodes that work in a way that is neutral to QUIC versions have to work within the room defined by RFC 8999. Actual encoding of CID fields are governed by each QUIC version, which is a two-party contract.",
          "createdAt": "2024-08-07T00:19:38Z",
          "updatedAt": "2024-08-07T00:19:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "One alternative we have here is to let SCID be set to match the value from other long header packets in the datagram, if there are other long header packets present, but to require it to be empty otherwise.",
          "createdAt": "2024-08-07T01:25:31Z",
          "updatedAt": "2024-08-07T01:25:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson \r\n> One alternative we have here is to let SCID be set to match the value from other long header packets in the datagram, if there are other long header packets present, but to require it to be empty otherwise.\r\n\r\nI think this works.\r\n\r\nIn the case of coalescing with long header packets, this approach has the least impact to existing implementations and to future versions of QUIC. In the case of coalescing with short header packets, any QUIC version only needs DCID to route the packet; that is a property of Invariants.",
          "createdAt": "2024-08-07T02:01:09Z",
          "updatedAt": "2024-08-07T02:01:09Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 on matching other long headers in the packet, empty if only short headers.\r\n\r\nIt is the right compromise between compatibility and privacy. If there are only short header packets in the datagram, adding a source CID leaks information, enables correlation of flows, etc. But if there are long headers, there is no info leaks, and compatibility requires adding a matching source ID.",
          "createdAt": "2024-08-07T16:46:28Z",
          "updatedAt": "2024-08-07T16:48:24Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOMaSf_M6SJcPY",
      "title": "Rate limit or rate limit over time",
      "url": "https://github.com/martinthomson/train-protocol/issues/14",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Given that rate limit is applied over a period of time, it might make sense to signal what that time is.\r\n\r\nOne option is to fix the time window (or token bucket depth).  Another might be to specify a number of time windows as part of the rate specification.\r\n\r\nThe problem with having multiple time buckets is that it makes a straight linear comparison more difficult.  Is 5Mbps over 4 seconds higher than 4Mbps over 5 seconds (or 6 seconds)?",
      "createdAt": "2024-08-07T01:11:44Z",
      "updatedAt": "2024-08-07T16:52:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. I mean we should specify the comparison as:\r\n~~~\r\n x > a === (x.rate > a.rate || (x.rate == a.rate && x.period < a.period))\r\n~~~\r\nThen allocate code point that that are strictly ordered, allowing a straight 6 bit compare by the middle boxes.",
          "createdAt": "2024-08-07T16:52:08Z",
          "updatedAt": "2024-08-07T16:52:08Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOMaSf_M6SJj_T",
      "title": "Pick some limits",
      "url": "https://github.com/martinthomson/train-protocol/issues/15",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We need to draw on two sources for this: the rates that network operators set in practice; and, the rates that video hosting services operate at in practice.\r\n\r\nThis might not need to be the union of the two sets, nor does it necessarily need to be the intersection of the two sets, though I would suggest that something closer to the intersection is superior.",
      "createdAt": "2024-08-07T01:33:58Z",
      "updatedAt": "2024-08-07T01:33:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOMaSf_M6ToJJ9",
      "title": "No need for request frame, but maybe echo frame",
      "url": "https://github.com/martinthomson/train-protocol/issues/21",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 7.2 includes \"TODO: Define a new frame type for requesting that a peer send a TRAIN packet\", but I do not think that this is needed. TRAIN is asymmetric: the opportunities created by a TRAIN sender measure the rate limits applicable to that sender. The sender can chose to send as many TRAIN as necessary for the local rate management. \r\n\r\nOn the other hand, we may need to define an \"echo\" frame to send the measured values back to the peer.",
      "createdAt": "2024-08-21T00:55:49Z",
      "updatedAt": "2024-08-27T14:01:39Z",
      "closedAt": "2024-08-27T14:01:39Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "I agree about the sender side of this: a sender can decide how often it wants to make an opportunity to mark, if at all.",
          "createdAt": "2024-08-21T02:26:19Z",
          "updatedAt": "2024-08-21T02:26:19Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's leave this open as we debate the feedback part, or its absence.",
          "createdAt": "2024-08-21T06:13:04Z",
          "updatedAt": "2024-08-21T06:14:20Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOMaSf_M6Uj0CG",
      "title": "Privacy considerations",
      "url": "https://github.com/martinthomson/train-protocol/issues/26",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@martinthomson has prepared PR #25 to add a \"privacy analysis\", but I think the discussion of that matter would be better done in an issue than in a PR.",
      "createdAt": "2024-08-28T15:24:48Z",
      "updatedAt": "2024-08-30T01:37:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "My first step in the analysis would be to check on models of \"the system\". PR #25 considers a simple client-network-server model, but when it comes to real time communication we may want to also consider peer-network-peer (e.g., a web RTC call after doing ICE, etc.) and peer-network-relay-(relays)-relay-network-peer (the MoQ model). And of course the VPN model: client - VPN - network - server. We may also want to consider what happens in the emerging oblivious model: client to first relay (knows the client, does not know the activity), client to second relay through first relay (knows the activity, does not know the client)\r\n\r\nThen I would look at the privacy assets in these model. I think I can list (and maybe exclude) the following: identity of parties, activities in which they engage.\r\n\r\nAnd I would look at the avenue of attacks. I think that we are mostly concerned by passive observation of traffic, and I can think about a series of attacks on privacy:\r\n\r\n- Client identity. It is not a concern for TRAIN in the models in which the IP addresses are exposed, but what of the VPN or Oblivious model? Is the TRAIN activity somehow observable through a VPN? Can it be used to correlate clear text traffic with a source?\r\n- Client capability (and thus identity): Supposing that at least in a deployment phase TRAIN will be rare, TRAIN usage reveals that the client is part of the early deployment. That can be part of fingerprinting. \r\n- Client activity: using TRAIN may reveal that the endpoints are engaged in some form of realtime application. Is that more information than already available?\r\n- Client RTT, thus revealing usage of a VPN at cleint or server side -- the attack that is most concerning with the Spin bit. Can attackers measure the time between action (TRAIN packet) and reaction (traffic is reshaped to meet suggested bandwidth)?\r\n\r\nMaybe we can brainstorm some more and think of more of such attacks.\r\n\r\nAnd then, if we do find some of those attacks convincing, maybe we can start thinking of countermeasures. Maybe some form of greasing, e.g., sending TRAIN packets occasionally even if the application is not trying to shape video. Or, deliberately injecting wrong valued TRAIN packets end-to-end, with fake limits that are then ignored. Maybe doing that will require making the payload of train a bit more complex.",
          "createdAt": "2024-08-28T15:49:19Z",
          "updatedAt": "2024-08-28T15:49:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Hmm.  I had thought this easier originally, then the PR got long.  And I clearly missed a few things.\r\n\r\nAs for deployment scenarios, I know that there are many options here, but really the only one that seems likely to result in action is server-to-client flows.  That's where the bulk of the data flows.  That's why I started with that framing.  #25 does talk about other interaction models, but spending too much effort on those seems less useful.\r\n\r\nI don't see the identity thing as an issue.  Same for leaking capability.  There is a segregation effect here that might apply in that it creates a discriminator that might separate flows into groups.  Where a set of flows might have previously been homogeneous, markings will separate them out.  More so past the point that rate limit signals are applied, but that very much depends on the deployment scenarios.\r\n\r\nIf this goes ahead, then some client software will turn this on and it will be visible.  Hopefully, that is a popular stack. Hopefully that stack just turns this on always, not conditionally based on the application.  Then the privacy risk is negligible.  If all flows from all browsers had this enabled, there is no distinguishing value to the signal being present.  It will only be used by a limited number of services, but those services would be identifiable from IP, so no big deal there either.  That eliminates any concerns about whether this being on or off leaks information.\r\n\r\nMaybe that's the part that needs highlighting.  That this leaks information if it is exceptional, so don't make it exceptional.\r\n\r\nThe RTT thing seems like it isn't even worth mentioning.  There are much, much better passive RTT leaks in QUIC.  The reaction to a signal is not unambiguous.  It's also only really going to be effective if the flow is isolated, such that the congestion control response doesn't suppress it instead.  In that case, the congestion control response carries the signal anyway.\r\n\r\n\r\n\r\n",
          "createdAt": "2024-08-29T00:34:52Z",
          "updatedAt": "2024-08-29T00:34:52Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that \"sticking out\" is the first concern, and that we should encourage stacks to turn it on.\r\n\r\nI think there is also some value in scrambling the signal, i.e., originating occasional TRAIN packets in which the VN is set to \"10 Mbps\" or \"20 Mbps\" instead of just TRAIN. Both for detecting possible misbehaving middle boxes, and for scrambling the signals that can be snooped.\r\n\r\nI disagree that \"bits are coming from the server\". In the videoconference use case, bits are coming from the client as well.\r\n\r\nI think we should think a little more about \"client -- VPN -- network -- server\". Assume an attacker that sees the traffic in and out of the VPN. Does TRAIN >VPN provide information to tie the VPN -- server traffic to a specific client -- VPN flow?",
          "createdAt": "2024-08-29T03:24:30Z",
          "updatedAt": "2024-08-29T03:24:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "I've added a paragraph about adding some chaff.  That won't be 100% effective (any rate limit that is applied will establish a ceiling).\r\n\r\nAs for videoconferencing, I'm not saying that we don't have something, but that it is not a dominant scenario and the privacy/utility trade-off is not ideal.  There is text on that point already, but it doesn't make a simple recommendation.\r\n\r\nBefore we talk about VPNs, do you think that this only makes sense for single-subscriber connections to access networks?  That is, a major transit provider probably won't be doing this for the interconnect flows that move from one ISP to another.  \r\n\r\nSeparately, anything *inside* the VPN tunnel will be protected completely (I hope), so it is only the marking that is applied outside the tunnel that matters.  The real risk there, as already identified, is the upstream marking (client-to-server).",
          "createdAt": "2024-08-29T04:01:09Z",
          "updatedAt": "2024-08-29T04:01:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Oh, and \ud83e\udd26, me.  A local ISP won't be able to apply signals to VPN traffic, because the endpoint that receives them is the VPN host.  I doubt that the unprotected link (VPN -> server) will need or want to apply markings, but if they do it will be without information about the client.\r\n\r\nSo I think that VPNs aren't that big of a deal.  The only scenario that bothers me is maybe [draft-ietf-masque-quic-proxy](https://ietf-wg-masque.github.io/draft-ietf-masque-quic-proxy/draft-ietf-masque-quic-proxy.html), but even that looks good if encryption is used (which it should be).",
          "createdAt": "2024-08-29T04:17:11Z",
          "updatedAt": "2024-08-29T04:17:11Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I was concerned about a third party inserting fake TRAINs in the \"network\" section to check whether effects are noticeable in the \"vpn\" section. Suppose VPN serves clients A, B, C. Attacker sets a TRAIN mark on traffic on 5-tuple S-D-s-d-udp between the server and the VPN. A receives it, passes it to the server, and now traffic between VPN and A drops to 5 Mps. Attacker confirms by setting another mark at 10 Mbps, and observes a bit later traffic between VPN and A increase to 10 Mbps. Attacker concludes that outside address D matches A.",
          "createdAt": "2024-08-29T04:27:54Z",
          "updatedAt": "2024-08-29T04:27:54Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Oh, that's potentially scary, but isn't that possible with packet dropping as well?  The congestion response from the affected connection is fairly easy to trigger.",
          "createdAt": "2024-08-29T04:31:22Z",
          "updatedAt": "2024-08-29T04:31:22Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess there are multiple attack vectors. ECN bits could also be used that way. Should we recommend that VPN just wash out the signal? (And ECN bits, of course.) OTOH TRAIN is a much more powerful signal than ECN. With ECN, you will need to re-mark pretty much all packets.",
          "createdAt": "2024-08-29T04:33:47Z",
          "updatedAt": "2024-08-29T04:36:11Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Generally the pattern is \"sneak signal into encrypted VPN, correlate with encrypted changes in VPN.\" Of course, there is a converse issue. What if there is a TRAIN signal on the outer envelope of the VPN. Should it be copied to the packets exiting the VPN?",
          "createdAt": "2024-08-29T04:37:13Z",
          "updatedAt": "2024-08-29T04:37:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "The default, and safe, answer there is that the TRAIN signal is absorbed by the VPN.  I realize that there is some value in having that information available, but it might be better to look for the VPN to provide feedback to the client, rather than propagate it end-to-end in that case.",
          "createdAt": "2024-08-29T04:40:56Z",
          "updatedAt": "2024-08-29T04:40:56Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that I could make the privacy text shorter and simpler.\r\n\r\nWe may be concerned that the values advertised by TRAIN are leaking the network preferences for some servers or applications. This leaking out part is largely by design: networks that advertise a specific supported rate are revealing that they are configured to do so. The actual throughput can of course be measured by on path observers, so we can argue that advertising a TRAIN parameter does not provide any information that is not already observable. It may be more convenient for observers to capture a few TRAIN packets than to keep counters of all traffic seen, but not by much -- Cisco's NetFlow, for example, does this measurement already. Maybe say that in the introduction of the privacy section.\r\n\r\nAfter that there are just a few important issues, and we should stick to that:\r\n\r\n* sticking out\r\n* compromising metadata protected by VPN\r\n\r\n",
          "createdAt": "2024-08-29T17:24:46Z",
          "updatedAt": "2024-08-29T17:24:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Do you want to suggest something?",
          "createdAt": "2024-08-29T23:41:41Z",
          "updatedAt": "2024-08-29T23:41:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I took a first shot with PR #27",
          "createdAt": "2024-08-30T01:37:38Z",
          "updatedAt": "2024-08-30T01:37:38Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDOMaSf_M52R5o2",
      "title": "Transport parameter and trigger version",
      "url": "https://github.com/martinthomson/train-protocol/pull/3",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR proposes:\r\n\r\n* define a \"trigger\" version,\r\n* use a transport parameter to indicate support of the feature,\r\n* hint that we need to add text specifying use of trigger version by routers",
      "createdAt": "2024-07-24T01:33:03Z",
      "updatedAt": "2024-08-06T09:28:47Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "022b282cbc687571308770e137facba0e1450691",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "ch-review-1",
      "headRefOid": "e0492e22cafcc6ae18a31ec33604fd25e83b28f3",
      "closedAt": "2024-08-06T09:28:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As @martinthomson says, we do not need a TP.\r\n\r\nBut :+1: to having a trigger version. Unless we do, middleboxes might rewrite handshake packets, which end ups as a packet loss to endpoints that do not understand the Train protocol.\r\n\r\nIMO, trigger version can be independent from the base version (e.g., V1).\r\n\r\nThe protocol can be as simple as below, with zero negotiation:\r\n* the sender unilaterally, and occasionally sends long header packet carrying the trigger version\r\n* middleboxes can rewrite this packet\r\n* the receiver receives the packet, and verifies that the received packet carries the correct CID pair. If they do, and the version number is changed, then that's the signal from the middlebox.\r\n\r\nPS. Thd downside of using the CID pair as a way to prevent off-path spoofing is that Train will not work when QUIC is used with zero-length CIDs _in both directions_. But such use never exist in practice, so we do not need to care.",
          "createdAt": "2024-07-25T00:14:56Z",
          "updatedAt": "2024-07-25T00:19:17Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I assumed two trigger versions in the PR, but @kazuho has a point. It would be better to have just one set of trigger values, etc. But then there is the little issue of how to decrypt packets, etc.",
          "createdAt": "2024-07-25T00:43:08Z",
          "updatedAt": "2024-07-25T00:43:08Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema Thanks. I think all we need to do is to agree on how the Train packets are checksummed. IMO, the easiest way would be to reuse that of QUIC v1 Initial packets with a different salt.\r\n\r\nPS. But taking a step further, I do not think we need to rewrite packets when middleboxes can simply inject them, please see #5.",
          "createdAt": "2024-07-25T01:05:17Z",
          "updatedAt": "2024-07-25T01:06:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6C317a",
          "commit": {
            "abbreviatedOid": "f87276d"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-24T05:30:45Z",
          "updatedAt": "2024-07-24T05:30:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't think that we need a transport parameter.  We do, however, probably want a trigger version, but I think that this is just the version of QUIC that we are talking about, which can be a completely new version rather than an alias for v1 or v2.  WDYT?",
              "createdAt": "2024-07-24T05:30:45Z",
              "updatedAt": "2024-07-24T05:30:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6C9Oxi",
          "commit": {
            "abbreviatedOid": "f87276d"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-24T15:32:11Z",
          "updatedAt": "2024-07-24T15:32:11Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Yes, a version number negotiation or a parameter negotiation have similar properties. But then we need to express how we do that. I assume we can do that as a robust version negotiation (need to look the V2 and negotiation drafts). Start with V1 or V2, upgrade to negotiated trigger. And then, add a definition of the \"echo_max\" frame whose support goes with the negotiated version.",
              "createdAt": "2024-07-24T15:32:11Z",
              "updatedAt": "2024-07-24T15:32:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DAzMG",
          "commit": {
            "abbreviatedOid": "f87276d"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T00:37:40Z",
          "updatedAt": "2024-07-25T00:37:40Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": " I remove that text and added version negotiation and a frame for sending the bandwidth. ",
              "createdAt": "2024-07-25T00:37:40Z",
              "updatedAt": "2024-07-25T00:37:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DJ875",
          "commit": {
            "abbreviatedOid": "95d1367"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T20:36:29Z",
          "updatedAt": "2024-07-25T21:21:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nthat on-path network elements are authorized to rewrite. Receiving packets\r\n```",
              "createdAt": "2024-07-25T20:36:29Z",
              "updatedAt": "2024-07-25T21:21:15Z"
            },
            {
              "originalPosition": 25,
              "body": "Probably we need to discuss this separately?\r\n\r\nAs much as I personally want to see the rewritten packet carry the bandwidth the receiver of that packet can consume, this design does not work well using different routes in both directions (e.g., connection that uses satellite in one direction and DSL in the another).",
              "createdAt": "2024-07-25T21:11:33Z",
              "updatedAt": "2024-07-25T21:21:15Z"
            },
            {
              "originalPosition": 58,
              "body": "If we are to have a mechanism in QUIC that transmits the bandwidth information, I think we need a TP, so that the feature set is negotiated by a secure mechanism (i.e., exchanged as part of the TLS handshake transcript).\r\n\r\nInitial packets can be spoofed, therefore the opt-in signal of Train can be spoofed (by spoofing an Initial packet that carries the trigger version).",
              "createdAt": "2024-07-25T21:20:19Z",
              "updatedAt": "2024-07-25T21:21:15Z"
            },
            {
              "originalPosition": 63,
              "body": "Did you mean\r\n```suggestion\r\n  Bandwidth (i),\r\n```",
              "createdAt": "2024-07-25T21:21:07Z",
              "updatedAt": "2024-07-25T21:21:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DKlfv",
          "commit": {
            "abbreviatedOid": "95d1367"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T23:01:19Z",
          "updatedAt": "2024-07-25T23:01:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I am removing that text. Routing is asymmetric, intermediaries do not always know the pacing rate in the other direction.",
              "createdAt": "2024-07-25T23:01:19Z",
              "updatedAt": "2024-07-25T23:01:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DKlpI",
          "commit": {
            "abbreviatedOid": "95d1367"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T23:02:09Z",
          "updatedAt": "2024-07-25T23:02:09Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Let's discuss the TP or not in a different PR.",
              "createdAt": "2024-07-25T23:02:09Z",
              "updatedAt": "2024-07-25T23:02:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DKlsB",
          "commit": {
            "abbreviatedOid": "95d1367"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T23:02:22Z",
          "updatedAt": "2024-07-25T23:02:22Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Fixing.",
              "createdAt": "2024-07-25T23:02:22Z",
              "updatedAt": "2024-07-25T23:02:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DsAOr",
          "commit": {
            "abbreviatedOid": "e0492e2"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-31T07:09:05Z",
          "updatedAt": "2024-07-31T07:09:16Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "My opinion is that QUIC shouldn't need to pass this signal.  Applications will generate their own signaling based on this, as necessary.  For instance, in a streaming video app, the bandwidth cap will determine how the client requests new video chunks.  There is no direct need to tell the server what to do.\r\n\r\nI can't see a generic signaling mechanism being used in most of the cases we're talking about, so I'd rather not define one.",
              "createdAt": "2024-07-31T07:09:05Z",
              "updatedAt": "2024-07-31T07:09:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6DsJft",
          "commit": {
            "abbreviatedOid": "95d1367"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-31T07:29:11Z",
          "updatedAt": "2024-07-31T07:29:11Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "The signal can be useful as a hint for congestion control. This is indeed debatable, since the signal indicates a theoretical maximum, not the actual value, and CC will still have to discover the available bandwidth. But BBR, for example, has special code to detect on-path pacers. If the limit is 20 Mbps and the CC algorithms gets it slightly too high, say 21 Mbps, this can result in lots of errors. Knowing the limit would avoid such failure modes. But then again, trusting the limit could result in unnecessary slowdowns.",
              "createdAt": "2024-07-31T07:29:11Z",
              "updatedAt": "2024-07-31T07:29:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOMaSf_M52f_UR",
      "title": "Move more to a single new version",
      "url": "https://github.com/martinthomson/train-protocol/pull/7",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Expand the algorithms for setting and reading signals as well.",
      "createdAt": "2024-07-25T18:12:46Z",
      "updatedAt": "2024-08-06T09:28:47Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "022b282cbc687571308770e137facba0e1450691",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "new-version",
      "headRefOid": "79f9229a863f2e1b16832f4571278750a9e70deb",
      "closedAt": "2024-08-06T09:28:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I'm missing something, but I do not quite follow. Specifically, I do not see how the client decodes the server's first flight (e.g., QUIC v1 Initial).\r\n\r\nConsider the following example:\r\n* client sends a QUIC Initial carrying compatible upgrade (v1, v4, vTBDTRAIN)\r\n* server sends a QUIC vTBDTRAIN packet (IIUC, that is what the PR says)\r\n* no middlebox rewrites the server's first flight\r\n* client receives server's first flight carrying vTBDTRAIN\r\n\r\nNow, the problem is that the client cannot tell if the server's packet was encrypted (i.e., checksummed) using v1 or v4. So it cannot do anything.\r\n\r\nIs the intent to let the server at first send a v1 or v4 depending on the QUIC version it chooses, and then, after there is an acknowledge from the client indicating that the version negotiation is complete, send a vTBDTRAIN packet using the packet protection scheme of the selected version?\r\n\r\nWhile that is possible, I'm not sure if it's very simple. I think the design would be simpler if we just let the endpoints send and receive the QUIC version that they chose, and also let them send vTBDTRAIN packets that do not carry any information of the end-to-end connection (as stated in #8).",
          "createdAt": "2024-07-26T04:14:32Z",
          "updatedAt": "2024-07-26T04:14:32Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that @kazuho's comment is related to issue #8. My reasoning is the the server should not send VERSION_TRAIN before the client does. That means, let the packets carrying the full handshake carry the negotiated version number. After that, I think we could send \"train probes\" in handshake packets, but sending them as coalesced long header packets in front of 1RTT packets should also works.",
          "createdAt": "2024-07-26T04:35:58Z",
          "updatedAt": "2024-07-26T04:35:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema \r\n> I think that @kazuho's comment is related to issue https://github.com/martinthomson/train-protocol/issues/8.\r\n\r\nYes.\r\n\r\n> My reasoning is the the server should not send VERSION_TRAIN before the client does. That means, let the packets carrying the full handshake carry the negotiated version number. After that, I think we could send \"train probes\" in handshake packets, but sending them as coalesced long header packets in front of 1RTT packets should also works.\r\n\r\nI'm not fully certain if relying on Handshake packets is a good idea.\r\n\r\nThat is because, as the handshake concludes, QUIC v1 discards the Initial and Handshake keys. Therefore, assuming we want to retrieve bandwidth information after the handshake or when the client migrates to a new path, we have to validate the UDP datagram carrying the bandwidth either by: a) checking the CID-pair (which would be non-zero length in practice) of the vTBDTRAIN packet, or by b) validating the short header QUIC packet that follows the vTBDTRAIN packet.\r\n\r\nEither ways, if vTBDTRAIN packets are to carry only the bandwidth (with potentially having a short header packet coalesced to the same UDP datagram), handshake of any version of QUIC will work. In other words, we achieve QUIC version neutrality, so that would be good.",
          "createdAt": "2024-07-26T14:42:36Z",
          "updatedAt": "2024-07-26T14:42:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I am a bit concerned that we have 2 pending PRs and a big design question #8. If we believe the argument in #8 calling for the design to be version neutral, then we cannot really use version negotiation. That would move us back to negotiating a transport parameter for \"support of TRAIN\", after which parties can emit packets starting with a long header with \"version = TRAIN\" and CID per path, coalesced with regular \"version=negotiated\" packets. The peer would then echo the bandwidth value found in the overwritten TRAIN headers in a TRAIN frame.\r\n\r\nI could rewrite PR #3 to match that design, but I am a bit concerned that rewriting both PR #3 and this PR (#7) will lead to merge conflict. I would propose that we merge at least one of these 2 PRs first, and then rewrite towards the desired solution in a rewritten PR.",
          "createdAt": "2024-07-28T03:46:27Z",
          "updatedAt": "2024-07-28T03:46:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Yeah, perhaps we can organize a call to go over the details.  There are a couple of core questions here that might be easier to resolve that way.  My sense is that we have some questions about versions and how they are used.\r\n\r\n@kazuho, you know I'm going to ask you to co-author if you keep providing excellent contributions. :)",
          "createdAt": "2024-07-31T07:27:49Z",
          "updatedAt": "2024-07-31T07:27:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6DJtwk",
          "commit": {
            "abbreviatedOid": "79f9229"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Yes, that works. I will update my own PR to avoid merge conflicts.",
          "createdAt": "2024-07-25T20:13:34Z",
          "updatedAt": "2024-07-25T20:13:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6DJt-1",
          "commit": {
            "abbreviatedOid": "79f9229"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T20:13:50Z",
          "updatedAt": "2024-07-25T20:13:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMaSf_M53gxMO",
      "title": "Add Christian as author.",
      "url": "https://github.com/martinthomson/train-protocol/pull/9",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-06T02:00:20Z",
      "updatedAt": "2024-08-06T02:23:42Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "022b282cbc687571308770e137facba0e1450691",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "author-ch",
      "headRefOid": "6a1948d46058f6af5c98f4c46dd245316ae123d9",
      "closedAt": "2024-08-06T02:23:38Z",
      "mergedAt": "2024-08-06T02:23:38Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "704f8984eb13db8d31c6f077a917f5d59185c9c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6EVGpm",
          "commit": {
            "abbreviatedOid": "4803f62"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T02:01:40Z",
          "updatedAt": "2024-08-06T02:01:41Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n  -\r\n```",
              "createdAt": "2024-08-06T02:01:41Z",
              "updatedAt": "2024-08-06T02:01:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6EVGuC",
          "commit": {
            "abbreviatedOid": "270f840"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T02:01:59Z",
          "updatedAt": "2024-08-06T02:02:00Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n    fullname: Christian Huitema\r\n    org: Private Octopus Inc.\r\n    email: huitema@huitema.net\r\n```",
              "createdAt": "2024-08-06T02:01:59Z",
              "updatedAt": "2024-08-06T02:02:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOMaSf_M53g7GV",
      "title": "Rework design",
      "url": "https://github.com/martinthomson/train-protocol/pull/10",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This changes the design to be a discrete packet.  The signal is carried in the low six bits of the first octet (which is easy to rewrite).\r\n\r\nPackets with this version and sent independent of the negotiated version.\r\n\r\nI took a few liberties, but there are still a lot of TODO items in here.",
      "createdAt": "2024-08-06T02:43:13Z",
      "updatedAt": "2024-08-20T07:00:27Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "704f8984eb13db8d31c6f077a917f5d59185c9c1",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "signal-switch",
      "headRefOid": "279a6ed9bb865808b1821c3b766d66c1f472fa76",
      "closedAt": "2024-08-20T06:57:13Z",
      "mergedAt": "2024-08-20T06:57:13Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "8c9b349520dce84fe71db5839532aa0bbb4cd678"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6EWDi_",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for revising the text. Looks good to me.\r\n\r\nI've left my comments below, but I'm fine merging this PR in its current form and having the discussion later.",
          "createdAt": "2024-08-06T06:18:43Z",
          "updatedAt": "2024-08-06T06:32:04Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Not that we have to do in this PR, but do we want to point out that the congestion point might be somewhere else that the node that is advertising the rate limit?",
              "createdAt": "2024-08-06T06:18:43Z",
              "updatedAt": "2024-08-06T06:32:04Z"
            },
            {
              "originalPosition": 230,
              "body": "I wonder if this is a needless restriction due to following reasons:\r\n* Future versions of QUIC might use SCID for different purposes.\r\n* QUIC v1 allows use of long header packets mid-connection (see [Section 14.4.1 of RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-pmtu-probes-containing-sour)), but there is no such restriction. I'm not sure if there is a reason to diverge from the design that we already have.\r\n\r\nMy preference of moving forward would be to state SCID and DCID fields should be filled as defined by the QUIC version used by the endpoints, and add a reference to the section of RFC 9000 pointed out above.",
              "createdAt": "2024-08-06T06:26:33Z",
              "updatedAt": "2024-08-06T06:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6EXgBl",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T09:16:13Z",
          "updatedAt": "2024-08-06T09:16:14Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Yeah, I thought about that as well.  But this is a packet that uses the TRAIN version, for which we can define the use of the SCID field.  Absent a strong reason to set it to something specific, it's best to save the extra bytes.\r\n\r\nThat is, if another QUIC version that is in use needs the field, then they can describe how to fill out the field in packets for that version.\r\n\r\n(In retrospect, perhaps we could have removed this field from the invariants...)",
              "createdAt": "2024-08-06T09:16:13Z",
              "updatedAt": "2024-08-06T09:16:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6EXgYS",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T09:16:52Z",
          "updatedAt": "2024-08-06T09:16:52Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Good call, I added something.",
              "createdAt": "2024-08-06T09:16:52Z",
              "updatedAt": "2024-08-06T09:16:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Eaqnr",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T15:05:59Z",
          "updatedAt": "2024-08-06T15:05:59Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Thanks.\r\n\r\nAm I correct to interpret what you are saying is that, for train packets used by QUIC v1, we can define how the SCID field is filled, but we might want to keep room for future QUIC versions to do something else?\r\n\r\nIf that's your argument, you have my +1.",
              "createdAt": "2024-08-06T15:05:59Z",
              "updatedAt": "2024-08-06T15:05:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Ebzv-",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T17:29:27Z",
          "updatedAt": "2024-08-06T17:29:27Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "I think the format of the TRAIN packet must be defined by the TRAIN version number. The parser logic is \"look at the VN, recognize the version and the packet type, parse accordingly.\" This does not involve looking at other coalesced packets in the same datagram. If we decide to change the format, we will have to set VN=TRAIN2.",
              "createdAt": "2024-08-06T17:29:27Z",
              "updatedAt": "2024-08-06T17:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Eb4Wr",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T17:39:53Z",
          "updatedAt": "2024-08-06T17:39:53Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "RFC 9000 section 12.2 says: \"Receivers MAY route based on the information in the first packet contained in a UDP datagram. Senders MUST NOT coalesce QUIC packets with different connection IDs into a single UDP datagram. Receivers SHOULD ignore any subsequent packets with a different Destination Connection ID than the first packet in the datagram.\r\n\r\nSuppose a coalesced packet with: \"Long, V=TRAIN, DCID=X, SCID=NULL\", then \"Long, type=handshake, V= 1, DCID=X, SCID=S\". Arguably, it does not meet the \"MUST NOT\", because the SCID of the first and second packets have different SCID.\r\n\r\nIf we want to not break that RFC 9000 rule, then if TRAIN packets are coalesced with long header packets, the SCID MUST be set to the same value used in the long header packets. ",
              "createdAt": "2024-08-06T17:39:53Z",
              "updatedAt": "2024-08-06T17:39:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Eb5H5",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T17:41:39Z",
          "updatedAt": "2024-08-06T17:41:39Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "On the other hand, if the TRAIN packet is coalesced only with short header packet, then filling in the SCID is arguably a privacy leak.",
              "createdAt": "2024-08-06T17:41:39Z",
              "updatedAt": "2024-08-06T17:41:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Eb7Fg",
          "commit": {
            "abbreviatedOid": "279a6ed"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am saying \"approve\" for practical reason: we need to add more text on deployment, security considerations, actual rate limits and possibly some kind of \"bucket size\" or \"enforcement period\", and maybe a discussion of extra frames like \"send TRAIN now\" or \"here is the TRAIN that I received\". For that, it is more convenient to just merge this PR, and have a base on which we can work.\r\n\r\nWe have a point of disagreement on the SCID of TRAIN packets. I would not hold the merge for that, as we can always fix that later, but we don't resolve it before checking we need to open an issue.",
          "createdAt": "2024-08-06T17:46:14Z",
          "updatedAt": "2024-08-06T17:52:53Z",
          "comments": [
            {
              "originalPosition": 273,
              "body": "Have we not decided to state some kind of bucket size or enforcement period as well?",
              "createdAt": "2024-08-06T17:46:14Z",
              "updatedAt": "2024-08-06T17:52:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Ed0s_",
          "commit": {
            "abbreviatedOid": "f6efaef"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T23:59:57Z",
          "updatedAt": "2024-08-06T23:59:57Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Let's merge this PR and continue the discussion on #13.",
              "createdAt": "2024-08-06T23:59:57Z",
              "updatedAt": "2024-08-06T23:59:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6Ed0u7",
          "commit": {
            "abbreviatedOid": "279a6ed"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-07T00:00:08Z",
          "updatedAt": "2024-08-07T00:00:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOMaSf_M53iB3Q",
      "title": "Add Kazuho as author.",
      "url": "https://github.com/martinthomson/train-protocol/pull/12",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-06T07:22:10Z",
      "updatedAt": "2024-08-06T09:19:34Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "704f8984eb13db8d31c6f077a917f5d59185c9c1",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "kazuho/coauthor-1",
      "headRefOid": "df225850cb98e2657c5a8a019ddd060ae95add00",
      "closedAt": "2024-08-06T09:19:31Z",
      "mergedAt": "2024-08-06T09:19:31Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "c0d72582b31f4212190807cb4dc4ebb51b12117e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6EXg8B",
          "commit": {
            "abbreviatedOid": "8f00606"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T09:17:54Z",
          "updatedAt": "2024-08-06T09:17:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    fullname:\r\n      :: \u5965 \u4e00\u7a42\r\n      ascii: Kazuho Oku\r\n```",
              "createdAt": "2024-08-06T09:17:54Z",
              "updatedAt": "2024-08-06T09:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6EXhk8",
          "commit": {
            "abbreviatedOid": "df22585"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-06T09:18:54Z",
          "updatedAt": "2024-08-06T09:18:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOMaSf_M540Olt",
      "title": "Allow SCID to match the next packet",
      "url": "https://github.com/martinthomson/train-protocol/pull/16",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #13.",
      "createdAt": "2024-08-20T07:00:54Z",
      "updatedAt": "2024-08-21T07:51:24Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "8c9b349520dce84fe71db5839532aa0bbb4cd678",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "scid-any",
      "headRefOid": "59433aae82c249eb96ed04d644bdcc2d778a41fc",
      "closedAt": "2024-08-21T07:51:23Z",
      "mergedAt": "2024-08-21T07:51:23Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "eeedccecd9fb95167ac71f28e5d95b85c33b0fa0"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Good catch.  Though I realize now, when writing this up, that this is not necessarily possible.\r\n\r\nLet's say that you process packets in order.  The order of events is something like this:\r\n\r\n1. You process the TRAIN packet.  It looks fine, but you can't validate the SCID yet.  You save the indicated rate for later.\r\n2. You process the v1 packet that follows.  It is fine and you handle it.\r\n3. You now go back to the indicated rate and apply it.\r\n\r\nAt what point do you recognize that the SCID in the TRAIN packet is bad?  You _could_, I guess, interrupt the processing of the v1 packet at the point that you read off the SCID and abort the entire thing.  That might be possible in our implementation, though it is a little bit weird because it requires acting on state that might not be saved otherwise.  But it's a bit intrusive and I can't see how that would be easy to do in a general fashion.\r\n\r\nI'm going to go with \"MAY\" for the requirement, because I can't see how this would be reliably implemented without a whole lot of back and forth.  The harm here is minimal, so if it isn't enforced, that's OK as long as the packet is well-formed.",
          "createdAt": "2024-08-21T02:24:12Z",
          "updatedAt": "2024-08-21T02:24:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6F_zwv",
          "commit": {
            "abbreviatedOid": "7e39cd4"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T13:59:36Z",
          "updatedAt": "2024-08-20T13:59:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6GEnQO",
          "commit": {
            "abbreviatedOid": "7e39cd4"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "We need to also update the text in section 5.2. Processing TRAIN Packets. Current text says \"A TRAIN packet MUST be discarded, along with any packets that come after it in the same datagram, if the Source Connection ID Length is non-zero.\"\r\n\r\nThe correct text ought to be something like:\r\n\r\n\"A TRAIN packet MUST be discarded, along with any packets that come after it in the same datagram, if the Source Connection ID is not consistent with the coalesced packets, as\r\nspecified in {{packet}}.\"",
          "createdAt": "2024-08-21T01:05:17Z",
          "updatedAt": "2024-08-21T01:05:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6GFsSt",
          "commit": {
            "abbreviatedOid": "59433aa"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T04:01:04Z",
          "updatedAt": "2024-08-21T04:01:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6GFyNs",
          "commit": {
            "abbreviatedOid": "59433aa"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T04:20:49Z",
          "updatedAt": "2024-08-21T04:20:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOMaSf_M540QCM",
      "title": "A protocol needs to support all three registries",
      "url": "https://github.com/martinthomson/train-protocol/pull/17",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "If this protocol is to be used.",
      "createdAt": "2024-08-20T07:05:05Z",
      "updatedAt": "2024-08-21T02:56:23Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "8c9b349520dce84fe71db5839532aa0bbb4cd678",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "need-all-three",
      "headRefOid": "5ba5bbe31e8d3be5735620bc028c2c13e376d591",
      "closedAt": "2024-08-21T02:56:23Z",
      "mergedAt": "2024-08-21T02:56:23Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "63d52317c857c3bff2760ba0f9e5b21c5fcfb759"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6F_0c_",
          "commit": {
            "abbreviatedOid": "5ba5bbe"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T14:00:36Z",
          "updatedAt": "2024-08-20T14:00:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOMaSf_M540Rjf",
      "title": "Fix aasvg glitch in diagram",
      "url": "https://github.com/martinthomson/train-protocol/pull/18",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The two \"+\" placed one over the other caused aasvg to think that it needed to draw a line.",
      "createdAt": "2024-08-20T07:09:12Z",
      "updatedAt": "2024-08-20T08:10:18Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "8c9b349520dce84fe71db5839532aa0bbb4cd678",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "picture-cleanup",
      "headRefOid": "b8ec427bc4114591b1e8cf284edce15da02e18f3",
      "closedAt": "2024-08-20T07:38:25Z",
      "mergedAt": "2024-08-20T07:38:25Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "083db779d0670fb6f0e781bd3c9783b294b81740"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOMaSf_M540qFf",
      "title": "Add something important",
      "url": "https://github.com/martinthomson/train-protocol/pull/19",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-20T08:09:37Z",
      "updatedAt": "2024-08-20T14:01:56Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "083db779d0670fb6f0e781bd3c9783b294b81740",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "emoji-logo",
      "headRefOid": "3037d2881ac942545928e42c120e054bb64e735d",
      "closedAt": "2024-08-20T08:10:15Z",
      "mergedAt": "2024-08-20T08:10:15Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "ba53331142ef39d50b0a23c7623b396fbc165381"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6F_1f7",
          "commit": {
            "abbreviatedOid": "3037d28"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Important indeed.",
          "createdAt": "2024-08-20T14:01:55Z",
          "updatedAt": "2024-08-20T14:01:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOMaSf_M540rGF",
      "title": "Automatic update of README.md",
      "url": "https://github.com/martinthomson/train-protocol/pull/20",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-20T08:12:05Z",
      "updatedAt": "2024-08-20T09:45:27Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "ba53331142ef39d50b0a23c7623b396fbc165381",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "update-readme",
      "headRefOid": "5e763fd7159f1d7e2ec0fb48287863a16e62dc1f",
      "closedAt": "2024-08-20T09:45:24Z",
      "mergedAt": "2024-08-20T09:45:24Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "99f926b7592d3694cff1eae4a4a48db8688de166"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOMaSf_M547H5T",
      "title": "NO need to request TRAIN",
      "url": "https://github.com/martinthomson/train-protocol/pull/22",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As @huitema notes in #21, the sender knows how often they need to send packets.\r\n\r\nI'll do a follow-up for acknowledgments/signals.",
      "createdAt": "2024-08-21T02:29:31Z",
      "updatedAt": "2024-08-21T07:51:36Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "99f926b7592d3694cff1eae4a4a48db8688de166",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "no-request",
      "headRefOid": "51d1fb2520a27161f4f98c813338ce55034befac",
      "closedAt": "2024-08-21T07:51:36Z",
      "mergedAt": "2024-08-21T07:51:36Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "df2c3455a21c4e11ac310013ad6f273d58159a54"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6GFssK",
          "commit": {
            "abbreviatedOid": "51d1fb2"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T04:02:20Z",
          "updatedAt": "2024-08-21T04:02:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6GFyVU",
          "commit": {
            "abbreviatedOid": "51d1fb2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T04:21:13Z",
          "updatedAt": "2024-08-21T04:21:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOMaSf_M547KvH",
      "title": "Feedback options",
      "url": "https://github.com/martinthomson/train-protocol/pull/23",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Expand on what is possible, but don't define anything.\r\n\r\nThis is my preferred outcome.\r\n\r\nCloses #21.",
      "createdAt": "2024-08-21T02:42:15Z",
      "updatedAt": "2024-08-27T20:59:39Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "99f926b7592d3694cff1eae4a4a48db8688de166",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "feedback",
      "headRefOid": "14ef8ef21d148a93d7b0f43d0660f1242b081a99",
      "closedAt": "2024-08-27T14:01:38Z",
      "mergedAt": "2024-08-27T14:01:38Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "6611acf70ad9a880939d8d7927800816491c0646"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6GFuFm",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "OK. I get that you do not want to define an end-to-end mechanism. Can you explain the downside of such a mechanism? How does the rationale to not do that differ from the reasons for including ECN reports in ACKs?",
          "createdAt": "2024-08-21T04:07:06Z",
          "updatedAt": "2024-08-21T04:09:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I am not a great fan of that solution. It assumes that senders keep track of which packet was coalesced with what other packet, and that receiving one implies receiving the other. But that's not a guarantee. For example, it could happen that the TRAIN packet is corrupted, but the next packet in the datagram is received just fine.",
              "createdAt": "2024-08-21T04:07:06Z",
              "updatedAt": "2024-08-21T04:09:47Z"
            },
            {
              "originalPosition": 22,
              "body": "That, too.",
              "createdAt": "2024-08-21T04:07:21Z",
              "updatedAt": "2024-08-21T04:09:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GG9nQ",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T07:27:37Z",
          "updatedAt": "2024-08-21T07:27:37Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "A corrupted TRAIN packet is unlikely to be easy to discard.  Assuming that it is, then that is fine.  I think.  Having ACKs operate by adjacency is a trick that our stack uses as well.\r\n\r\nTo answer your question about end-to-end, my argument is very specifically about end-to-end.  If the message does not hit the application, then it is middle-to-middle.  ECN differs because it is a message for the congestion controller.  This message is for the rate adaptation mechanisms in the application, not the QUIC stack.\r\n\r\nI can see why you would want to close the loop at the QUIC layer.  It's certainly possible.  I'm not opposed to it, I just prefer not to start out by specifying it.\r\n\r\nThe main case that I think might inform this decision is are HLS, Dash, and analogous video streaming protocols.  In those cases, the rate adaptation occurs by requesting a different quality level (or a rung on a ladder).  This is done without modifying the application at all, because rate adaptation is receiver driven in those protocols.  Having a potentially conflicting signal at the QUIC layer isn't helpful in those cases.  Given that these are the primary driver for this design, that weakens the case for a QUIC signal.",
              "createdAt": "2024-08-21T07:27:37Z",
              "updatedAt": "2024-08-21T07:28:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GLkOE",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T15:21:42Z",
          "updatedAt": "2024-08-21T15:21:42Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I see the case for \"application signal\". Perhaps we need to make it explicitly in the draft?",
              "createdAt": "2024-08-21T15:21:42Z",
              "updatedAt": "2024-08-21T15:21:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GQxuy",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T00:52:56Z",
          "updatedAt": "2024-08-22T00:53:00Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm trying to distill the commentary about application-layer signals.  I wonder how much of that needs to be memorialized.\r\n\r\n```suggestion\r\nThis document does not define a means for indicating what was received.\r\nHow a receiving application communicates the rate limit signal to a\r\nsending application will depend on the application in use.\r\n\r\nDifferent applications can choose different approaches. For example,\r\nin an application where a receiver drives rate adaptation, it might\r\nnot be necessary to define additional signaling.\r\n```",
              "createdAt": "2024-08-22T00:52:56Z",
              "updatedAt": "2024-08-22T00:53:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GUqnW",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T06:00:57Z",
          "updatedAt": "2024-08-22T06:00:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I may be wrong, but I believe a lot of arguments against adding feedback in the transport is the \"slippery slope\". If we automate the transport level feedback, there will be a great temptation to use the advertised rate as part of transport control or congestion control. The slippery part is that if we do that, we create an incentive for network operators to manipulate the advertised rates in order to influence transports, moving away from a pure application mechanism.\r\n\r\nMaybe capture your comment \"my argument is very specifically about end-to-end\".",
              "createdAt": "2024-08-22T06:00:57Z",
              "updatedAt": "2024-08-22T06:01:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GVPVT",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T07:31:18Z",
          "updatedAt": "2024-08-22T07:31:18Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "How about:\r\n\r\n```suggestion\r\nThis document does not define a means for indicating what was received.\r\nThat is, the expectation is that any signal is propagated to the application\r\nfor handling, not handled automatically by the transport layer.\r\nHow a receiving application communicates the rate limit signal to a\r\nsending application will depend on the application in use.\r\n\r\nDifferent applications can choose different approaches. For example,\r\nin an application where a receiver drives rate adaptation, it might\r\nnot be necessary to define additional signaling.\r\n```",
              "createdAt": "2024-08-22T07:31:18Z",
              "updatedAt": "2024-08-22T07:31:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GmvJ_",
          "commit": {
            "abbreviatedOid": "8167573"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "My last sticking point is, clarify whether the transmission and retransmission of TRAIN is decided by transport or by application.",
          "createdAt": "2024-08-24T03:04:57Z",
          "updatedAt": "2024-08-24T03:06:57Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I agree that the \"ack of coalesced packet\" works in practice. I can swallow hard and live with that. But then, do we even need to mention it? Defining it sort of implies that the transport will issue a new TRAIN if the first one was not acked. But if the signal is truly end-to-end, the decision to send the TRAIN packet probably belongs to the application.",
              "createdAt": "2024-08-24T03:04:57Z",
              "updatedAt": "2024-08-24T03:06:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6G1R1v",
          "commit": {
            "abbreviatedOid": "0e68bd4"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-27T05:02:19Z",
          "updatedAt": "2024-08-27T05:02:19Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ah, good point.  Maybe we should instead say:\r\n\r\n> This might help inform whether to send additional TRAIN packets in the event that a datagram is lost. However, rather than relying on transport signals, an application might be better able to indicate what has been received and processed.",
              "createdAt": "2024-08-27T05:02:19Z",
              "updatedAt": "2024-08-27T05:02:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6G1YVD",
          "commit": {
            "abbreviatedOid": "8167573"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-27T05:26:16Z",
          "updatedAt": "2024-08-27T05:26:16Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yes, that would do it. Also, \"TRAIN packets could be stripped from datagrams in the network\"... which means the datagram would be acknowledged, and nobody would be any wiser.\r\n\r\n",
              "createdAt": "2024-08-27T05:26:16Z",
              "updatedAt": "2024-08-27T05:26:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6G1-9F",
          "commit": {
            "abbreviatedOid": "14ef8ef"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice way to make the case for application level feedback.",
          "createdAt": "2024-08-27T06:43:59Z",
          "updatedAt": "2024-08-27T06:43:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOMaSf_M547un5",
      "title": "Attempt to explain the off path attack",
      "url": "https://github.com/martinthomson/train-protocol/pull/24",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a first shot at discussing the off path attack -- which can of course also be performed by on path attackers. It should address the discussion in issues #1 and #11.",
      "createdAt": "2024-08-21T05:13:17Z",
      "updatedAt": "2024-08-22T00:24:42Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "63d52317c857c3bff2760ba0f9e5b21c5fcfb759",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "spoof-attack",
      "headRefOid": "e62e0fea85190e7941850eb435608b4b3dd0296b",
      "closedAt": "2024-08-22T00:24:42Z",
      "mergedAt": "2024-08-22T00:24:42Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "5820570df65c55073251dfa7d4227112d5f70b17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6GHGl-",
          "commit": {
            "abbreviatedOid": "2ef082e"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Some editorial suggestions, but this looks great.  We're not recommending anything in particular, which is fine.",
          "createdAt": "2024-08-21T07:40:59Z",
          "updatedAt": "2024-08-21T07:48:58Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nobserve packets sent by an endpoint, create datagrams coalescing an\r\n```",
              "createdAt": "2024-08-21T07:40:59Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\npacket. Spoofed packets that seek to advertise a higher limit\r\nthan might otherwise be permitted also need to bypass any\r\n```",
              "createdAt": "2024-08-21T07:42:02Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nrate limiters. The attacker will thus get arbitrary TRAIN packets accepted by\r\n```",
              "createdAt": "2024-08-21T07:42:08Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nthe peer, with the result being that the endpoint receives a false\r\nor misleading rate limit.\r\n```",
              "createdAt": "2024-08-21T07:42:50Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nSome off-path attackers may be able to both\r\n```",
              "createdAt": "2024-08-21T07:43:28Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\narbitrary TRAIN packet and the observed packet, and send these datagrams\r\nsuch that they arrive at the peer endpoint before the original\r\n```",
              "createdAt": "2024-08-21T07:44:13Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            },
            {
              "originalPosition": 16,
              "body": "The one thing that I'd suggest adding.\r\n\r\n```suggestion\r\n\r\nThe recipient of a rate limit signal therefore cannot guarantee that\r\nthe signal was generated by an on-path network element. However,\r\nthe capabilities required of an off-path attacker are substantially\r\nsimilar to those of on path elements.\r\n\r\n```",
              "createdAt": "2024-08-21T07:47:33Z",
              "updatedAt": "2024-08-21T07:48:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6GOmoV",
          "commit": {
            "abbreviatedOid": "e62e0fe"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T21:28:44Z",
          "updatedAt": "2024-08-21T21:28:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDOMaSf_M55qJ2r",
      "title": "Privacy analysis",
      "url": "https://github.com/martinthomson/train-protocol/pull/25",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This is a little fiddly, but I think that the general conclusion makes sense:\r\n\r\n* Clients advertise support, but rarely need to send TRAIN packets.\r\n* ...except for real-time or other bidirectional exchange patterns.\r\n* ...maybe.\r\n* Servers use opportunities that clients offer, but probably don't care much about uplink, except for real-time/bidirectional exchanges.\r\n\r\nPrivacy is important, so I'd like to get this in a reasonable shape before we ship a -00.  It's probably the last thing to do though.",
      "createdAt": "2024-08-28T05:49:06Z",
      "updatedAt": "2024-08-30T06:20:28Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "6611acf70ad9a880939d8d7927800816491c0646",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "privacy-expanded",
      "headRefOid": "4b033052792bcef096a00450ffa519f5c35c0313",
      "closedAt": "2024-08-30T06:20:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "body": "Closing in favour of #27.",
          "createdAt": "2024-08-30T06:20:27Z",
          "updatedAt": "2024-08-30T06:20:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6HFrhZ",
          "commit": {
            "abbreviatedOid": "d3e818f"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "In short, you are saying that clients don't care because the actual rate can be observed, and service don't care because their access is shared between multiple connections.\r\n\r\nI don't think that you can separate client/server so neatly. Suppose a video conference application. Both client and server are trying to send and receive data, both need to tune the coding rate of video images -- and if we move to telepresence both could use very large bandwidth.",
          "createdAt": "2024-08-28T14:12:39Z",
          "updatedAt": "2024-08-28T14:12:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6HKPup",
          "commit": {
            "abbreviatedOid": "eab236b"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The unconditional part is useful. I am still concerned that the discussion of \"client privacy\" and \"server privacy\" is a bit optimistic.",
          "createdAt": "2024-08-29T03:28:38Z",
          "updatedAt": "2024-08-29T03:33:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I have a hard time parsing the first sentence of that paragraph. Do you mean \"The TRAIN is passively observable, and conveys information.\"? Also, not sure about \"availabity. Do you mean \"If the signal is only sent during specific client states, that provide information about those states\" ?",
              "createdAt": "2024-08-29T03:28:38Z",
              "updatedAt": "2024-08-29T03:33:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDOMaSf_M5555Hb",
      "title": "Alternative Privacy Consideration section",
      "url": "https://github.com/martinthomson/train-protocol/pull/27",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@martinthomson This is kind of an alternative view of the Privacy considerations. It is somewhat more compact than PR #25. ",
      "createdAt": "2024-08-30T00:18:30Z",
      "updatedAt": "2024-09-04T06:36:13Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "6611acf70ad9a880939d8d7927800816491c0646",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "privacy-considerations",
      "headRefOid": "0ae8e5b38fc6a0583410a08d50e81d0c1e92d2a8",
      "closedAt": "2024-09-04T06:36:02Z",
      "mergedAt": "2024-09-04T06:36:02Z",
      "mergedBy": "huitema",
      "mergeCommit": {
        "oid": "403aa244c1c9492013575cd180ebc0c1e2b5b28d"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson Thanks for the suggestions! I was a bit short on time, knew I should do a figure but skipped on it... I will be travelling tomorrow and out for the Labor Day weekend, so feel free to merge this. Or wait for @kazuho approval...",
          "createdAt": "2024-08-30T05:36:42Z",
          "updatedAt": "2024-08-30T05:36:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6HWazG",
          "commit": {
            "abbreviatedOid": "6062cbd"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Editorial suggestions only.  I like this better than mine.",
          "createdAt": "2024-08-30T02:08:39Z",
          "updatedAt": "2024-08-30T02:32:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n# Privacy Considerations {#privacy}\r\n```",
              "createdAt": "2024-08-30T02:08:39Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe focus of this analysis is the extent to which observing TRAIN\r\npackets could be used to gain information about endpoints.\r\nThis might be leaking details of how applications using QUIC\r\noperate or leaks of endpoint identity when using additional\r\nprivacy protection, such as a VPN.\r\n```",
              "createdAt": "2024-08-30T02:12:04Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nthe data rate limits set by TRAIN.\r\n\r\nThere are two avenues of attack that require more analysis:\r\n\r\n* that the passive observation of TRAIN packets might help identify or\r\n  distinguish endpoints; and\r\n* that active manipulation of TRAIN signals might help reveal the\r\n  identity of endpoints that are otherwise hidden behind VPNs or proxies.\r\n```",
              "createdAt": "2024-08-30T02:14:34Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\na few of these servers use TRAIN, any TRAIN packets\r\n```",
              "createdAt": "2024-08-30T02:15:53Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\n## Active manipulation of TRAIN to identify endpoints\r\n```",
              "createdAt": "2024-08-30T02:16:06Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nSuppose a configuration in which multiple clients use a VPN or proxy\r\n```",
              "createdAt": "2024-08-30T02:16:18Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nSuppose now that the attacker selects a flow on the link between the\r\nVPN/proxy and server. The attacker applies rate limit signals to TRAIN packets\r\nin that flow. The attacker chooses a bandwidth that is\r\nlower than the \"natural\" bandwidth of the connection. A reduction\r\nin the rate of flows between client and VPN/proxy might allow\r\nthe attacker to link the altered flow to the client.\r\n\r\n~~~ aasvg\r\n+--------+\r\n| Client |------.\r\n+--------+       \\      +-------+\r\n                  '---->|       |            +--------+\r\n+--------+              |  VPN  |<==========>|        |\r\n| Client |------------->|   /   |<==========>| Server |\r\n+--------+              | Proxy |<==========>|        |\r\n                  .---->|       |     ^      +--------+\r\n+--------+       /      +-------+     |\r\n| Client |======'                     |\r\n+--------+      ^           Apply rate limit signal\r\n                 \\\r\n                  \\\r\n               Observe change\r\n~~~\r\n```",
              "createdAt": "2024-08-30T02:27:04Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 76,
              "body": "I don't think we should say anything about opinions.\r\n\r\n```suggestion\r\nAn attacker that can manipulate TRAIN headers can also simulate\r\ncongestion signals by dropping packets or by setting the ECN CE bit.\r\nThat will also likely result in changes in the congestion response by\r\nthe affected client.\r\n```",
              "createdAt": "2024-08-30T02:28:35Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nA VPN or proxy could defend against this style of attack by removing TRAIN (and\r\nECN) signals. There are few reasons to provide per-flow rate limit signals in\r\nthat situation.  Endpoints might also either disable this feature or ignore any\r\nsignals when they are aware of the use of a VPN or proxy.\r\n```",
              "createdAt": "2024-08-30T02:32:00Z",
              "updatedAt": "2024-08-30T02:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6HWiXn",
          "commit": {
            "abbreviatedOid": "6062cbd"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Oh, and some alternative (punchier) headings.",
          "createdAt": "2024-08-30T02:33:01Z",
          "updatedAt": "2024-08-30T02:33:54Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n## Passive Attacks\r\n```",
              "createdAt": "2024-08-30T02:33:01Z",
              "updatedAt": "2024-08-30T02:33:54Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\n## Active Attacks\r\n```",
              "createdAt": "2024-08-30T02:33:38Z",
              "updatedAt": "2024-08-30T02:33:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMaSf_M6HX9x7",
          "commit": {
            "abbreviatedOid": "6062cbd"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-30T05:24:56Z",
          "updatedAt": "2024-08-30T05:24:56Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Github does not let me accept the suggestion. I will do it in a separate commit.",
              "createdAt": "2024-08-30T05:24:56Z",
              "updatedAt": "2024-08-30T05:24:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOMaSf_M558Je3",
      "title": "Add some more words to the text on applicability",
      "url": "https://github.com/martinthomson/train-protocol/pull/28",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The scoping section seemed a bit weak, so I spent some time on it.",
      "createdAt": "2024-08-30T08:26:24Z",
      "updatedAt": "2024-09-04T00:11:39Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "6611acf70ad9a880939d8d7927800816491c0646",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "uncertain-scope",
      "headRefOid": "fa1b27e23cd64ac6fb22f41dee518dc0edc628ae",
      "closedAt": "2024-09-04T00:11:35Z",
      "mergedAt": "2024-09-04T00:11:35Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "2a8638576867793486056ba8268ddd1c9a6fc43c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6HzPDk",
          "commit": {
            "abbreviatedOid": "fa1b27e"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine. I did a bit of double take on the last paragraph (downlink), because we have the classic scenario  \"teenager plays a videogame and competes for bandwidth\", but yes even so \"capacity is less likely to be split between multiple active flows.\"",
          "createdAt": "2024-09-03T19:53:36Z",
          "updatedAt": "2024-09-03T19:53:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOMaSf_M56y_Eb",
      "title": "Cite the registries the same way",
      "url": "https://github.com/martinthomson/train-protocol/pull/29",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-09T05:21:57Z",
      "updatedAt": "2024-09-10T00:46:34Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "1b2feb34a863163f9a675956da3a77aa73bc180f",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "iana-fixups",
      "headRefOid": "bbde820b1f999f46d1d3d1cf2b4febbb4fc0afa3",
      "closedAt": "2024-09-10T00:44:43Z",
      "mergedAt": "2024-09-10T00:44:43Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "dcec19303cb1cb4821e4a1a5ecdc6d53141386a1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6IhStS",
          "commit": {
            "abbreviatedOid": "bbde820"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Grease bit, uh? So much boiler plate, so much cut and paste...",
          "createdAt": "2024-09-09T16:42:51Z",
          "updatedAt": "2024-09-09T16:42:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOMaSf_M6BKyRj",
      "title": "Add self",
      "url": "https://github.com/martinthomson/train-protocol/pull/30",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-07T10:40:47Z",
      "updatedAt": "2024-11-07T17:36:39Z",
      "baseRepository": "martinthomson/train-protocol",
      "baseRefName": "main",
      "baseRefOid": "4756fbd4b546b9c035ce2b1092c348b5dda6f89e",
      "headRepository": "martinthomson/train-protocol",
      "headRefName": "jri/addself",
      "headRefOid": "46c3927e829046128d7e9804c1000f806e9f0cad",
      "closedAt": "2024-11-07T17:36:39Z",
      "mergedAt": "2024-11-07T17:36:38Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "fb4722399e78b1f5e5d9552eeb434916fc695259"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMaSf_M6QUIia",
          "commit": {
            "abbreviatedOid": "46c3927"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-07T14:46:47Z",
          "updatedAt": "2024-11-07T14:46:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6QUK0m",
          "commit": {
            "abbreviatedOid": "46c3927"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-07T14:50:08Z",
          "updatedAt": "2024-11-07T14:50:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMaSf_M6QUtLE",
          "commit": {
            "abbreviatedOid": "46c3927"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-07T15:35:33Z",
          "updatedAt": "2024-11-07T15:35:33Z",
          "comments": []
        }
      ]
    }
  ]
}